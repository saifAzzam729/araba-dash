import {useEffect, useMemo, useState} from "react";
import {useLocaleContext} from "@src/providers/LocaleProvider";
import {createSchema} from "@src/views/pages/products-attributes/edit-and-view/data";
import {useFieldArray, useForm} from "react-hook-form";
import {yupResolver} from "@hookform/resolvers/yup/dist/yup";
import {useMutation, useQuery, useQueryClient} from "react-query";
import ProductAttributesService from "@src/common/services/ProductAttributesService";
import showSuccessAlert from "@components/alert/showSuccessAlert";
import ProductOptionService from "@src/common/services/ProductOptionService";
import handleDeletePopup from "@src/views/pages/products-attributes/custom-components/HandleDeletePopup";
import handleDeleteMutation from "@components/alert/handleDeleteMutation";
import {replace} from "lodash";

export default function useViewAndEditDataManager({attributeItem, refetchingAllAttributes}) {

    const queryClient = useQueryClient()
    const [backendErrors, setBackendErrors] = useState([]);
    const {translate} = useLocaleContext();


    const schema = useMemo(() => {
        return createSchema(translate);
    }, [translate]);


    const FormMethods = useForm({
        resolver: yupResolver(schema),
    });


    const {fields, append, remove, update, replace,} = useFieldArray({
        control: FormMethods.control,
        name: "options", keyName: "autoGeneratedId", shouldUnregister: true,
    });

    // fetch attribute item by id
    useQuery(
        ['attributeItem', attributeItem.id],
        () => ProductAttributesService.getById(attributeItem.id),
        {
            onSuccess: ({data: fetchedItem}) => {
                const {setValue} = FormMethods;
                setValue('nameEn', fetchedItem.translations.en.name);
                setValue('nameAr', fetchedItem.translations.ar.name);
                setValue('publish', fetchedItem.publish);
                setValue('descriptionEn', fetchedItem.translations.en.description);
                setValue('descriptionAr', fetchedItem.translations.ar.description);

                const arrToReplace = fetchedItem.options.map(({id, publish, translations, iconFileUrl, iconFileSize, iconFileName}) => {
                    return {
                        optionId: id,
                        publish: publish,
                        translations: {
                            valueEn: translations?.en.value,
                            valueAr: translations?.ar?.value,
                            descriptionEn: translations?.en.description,
                            descriptionAr: translations?.ar?.description,
                        },
                        iconFileUrl: iconFileUrl,
                        iconFileSize: iconFileSize,
                        iconFileName: iconFileName
                    };
                });

                replace(arrToReplace);
            }
        }
    )

    /*
    *   Delete Attribute Option
    * */
    const {mutate: deleteAttributeOption} = useMutation(
        (data) => ProductOptionService.deleteObject(data),
        {
            onError: (error) => {
                setBackendErrors(error.response.data.formErrors);
            }
        }
    );

    const handleDeleteAttributeOptions = (optionId, index) => {
        if (optionId) {
            handleDeletePopup(deleteAttributeOption, optionId, () => {
                remove(index)
            })
            return;
        }
        remove(index)
    }


    const {mutate: deleteAttributeItem,} = useMutation(
        (data) => ProductAttributesService.deleteObject(data.id),
        {
            onSuccess: () => {
                refetchingAllAttributes()
                showSuccessAlert({});
            },
        }
    );
    const handleDeleteAttributeItem = (row) => {
        handleDeleteMutation(deleteAttributeItem, row)
    };


    /*
    *   Update attribute
    * */
    const {mutate: updateAttributeItem, isError} = useMutation(
        (data) => ProductAttributesService.update(attributeItem.id, data),
        {
            onSuccess: (data) => {
                queryClient.invalidateQueries({queryKey: ['products-attributes']})
                queryClient.invalidateQueries({queryKey: ['attributeItem']})
                showSuccessAlert({});
            },
            onError: (error) => {
                setBackendErrors(error.response.data.formErrors);
            }
        }
    );
    const prepareDataAndSubmit = ({
                                      icon,
                                      publish,
                                      nameEn,
                                      nameAr,
                                      descriptionEn,
                                      descriptionAr,
                                      options,
                                  }) => {

        const optionsToSend = options.map((opt, index) => {
            const optionObject = {
                publish: opt.publish,
                id: opt.optionId,
                translations: {
                    en: {
                        value: opt.translations.valueEn,
                        description: opt.translations.descriptionEn
                    },
                    ar: {
                        value: opt.translations.valueAr,
                        description: opt.translations.descriptionAr
                    }
                }
            };

            if (opt.icon) {
                optionObject.icon = opt.icon.item(0);
            }

            return optionObject;

        })

        const objectToSend = {
            icon: icon.item(0),
            publish: !!publish,
            translations: {
                en: {
                    name: nameEn,
                    description: descriptionEn
                },
                ar: {
                    name: nameAr,
                    description: descriptionAr
                }
            },
            options: optionsToSend,
        };
        updateAttributeItem(objectToSend)
    }

    const removeOptionFormItem = (autoGeneratedId) => {

        const toReplace = fields.filter((field) => field.autoGeneratedId !== autoGeneratedId);

        replace([]);
        setTimeout(() => {
            replace(toReplace);
        })
    }

    const handleAddOptionFormItem = async () => {
        const result = await FormMethods.trigger("options");
        if (!result) {
            return;
        }
        append({});
    }


    return {
        backendErrors,
        isErrorWithUpdateMutation: isError,

        FormMethods,
        removeOptionFormItem,
        fields,
        handleAddOptionFormItem,
        handleDeleteAttributeOptions,

        handleDeleteAttributeItem,

        prepareDataAndSubmit,
    }
}
